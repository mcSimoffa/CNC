PROC MS_3HP(INT M_NT,INT M_TC,REAL M_DIA,REAL M_Z,REAL M_X,REAL M_Y,REAL M_ALFA,REAL M_BETA,REAL M_GAMMA,REAL M_TOLL,STRING[20] M_TITO,INT M_ORIG,INT M_CHECK,STRING[32] M_TOOLN,INT M_TOOLD,INT M_DUPLO)
DEF REAL MEX[3],MEY[3],RAGGIO[3],ERG[3]
DEF REAL MS_ABS_INPUT,PUNX[3],PUNY[3],PUDX[3],PUDY[3]
DEF REAL SAB[3,2],M_I,M_F,M_POSZ
DEF BOOL STATUS
DEF STRING[60] FILEINI
DEF STRING[60] AUXIN
DEF STRING[60] AUXOUT
DEF STRING[100] SCRIVI
DEF STRING[60] RICHIAMANTE
DEF INT CODICE, T_INT

;***************************************
; CICLO DI MISURA FORO/PERNO PER SONDA
; CON TRE TOCCHI A ANGOLI DIVERSI
; SIEMENS 840D/828D  		        
; VER 10.1 15/02/2016             
;**************************************

;** CONTROLLO SE SIMULAZIONE O TEST************
IF $P_SEARCH OR $P_ISTEST OR $P_SIM OR $P_DRYRUN
 RET
ENDIF
;**********************************************

;****CONTROLLO QUAL'E' IL CICLO RICHIAMANTE****
RICHIAMANTE=$P_PROG[$P_STACK-1]
IF RICHIAMANTE=="_N_MS_3HP2_SPF"
 CODICE=1
ENDIF
IF RICHIAMANTE=="_N_MS_3HP34_SPF"
 CODICE=1
ENDIF
;**********************************************

;***** GESTIONE PIU SONDE**********************
FILEINI="/_N_CUS_DIR/_N_MS_INIS"<<M_NT<<"_SPF"
AUXIN="/_N_CUS_DIR/_N_MS_IN"<<M_NT<<"_SPF"
AUXOUT="/_N_CUS_DIR/_N_MS_OUT"<<M_NT<<"_SPF"
STOPRE
CALL FILEINI  ;richiamo file ini
IF ((CODICE==0) AND (MS_ACT==1))
 M=(MS_SON)
 G4 F1.2
ENDIF
CALL AUXIN    ;richiamo ausiliare ingresso
;**********************************************

;***** PARAMETRI DEL CICLO********
; ADDED FOR TOOL SHIFT
IF (MS_X_SHIFT==0) AND (MS_Y_SHIFT==0)		
	MS_D=$TC_DP6[$P_TOOLNO,$P_TOOL]
ELSE
	MS_D=MS_R_SPHERE					
ENDIF
MS_ABS_INPUT=ABS(MS_INPUTS)
M_POSZ=$AA_IW[MS_Z]-MS_L_TOOL

IF M_TC==1 ;sto usando un perno
M_I=-(M_DIA/2)-MS_D-MS_CS
M_F=-(M_DIA/2)+MS_D+MS_CS
ENDIF

IF (M_TC==2) OR (M_TC==3) ;sto usando un foro
 M_I=(M_DIA/2)-MS_D-MS_CS
M_F=(M_DIA/2)+MS_D+MS_CS
ENDIF

;calcolo punti di movimento
PUNX[0]=M_I*COS(M_ALFA)
PUNY[0]=M_I*SIN(M_ALFA)
PUNX[1]=M_I*COS(M_BETA)
PUNY[1]=M_I*SIN(M_BETA)
PUNX[2]=M_I*COS(M_GAMMA)
PUNY[2]=M_I*SIN(M_GAMMA)
PUDX[0]=M_F*COS(M_ALFA)
PUDY[0]=M_F*SIN(M_ALFA)
PUDX[1]=M_F*COS(M_BETA)
PUDY[1]=M_F*SIN(M_BETA)
PUDX[2]=M_F*COS(M_GAMMA)
PUDY[2]=M_F*SIN(M_GAMMA)

ATRANS X=M_X Y=M_Y

;***** mis primo punto *****
MS_MOVE(M_NT,PUNX[0],PUNY[0],,MS_RAPID)
MS_MOVE(M_NT,,,M_Z-MS_D,MS_RAPID)
G1 G90 G60 MEAS=MS_INPUTS F=MS_ST AX[MS_X]=(PUDX[0]-MS_X_SHIFT) AX[MS_Y]=(PUDY[0]-MS_Y_SHIFT)
MEX[0]=$AA_MW[MS_X]+MS_X_SHIFT
MEY[0]=$AA_MW[MS_Y]+MS_Y_SHIFT
IF $AC_MEA[MS_ABS_INPUT]==0
 MS_ALM(201)
ENDIF
G1 G90 G60 F=MS_RAPID AX[MS_X]=(PUNX[0]-MS_X_SHIFT) AX[MS_Y]=(PUNY[0]-MS_Y_SHIFT)

MS_MOVE(M_NT,PUNX[0],PUNY[0],,MS_RAPID)
IF M_TC<>2
MS_MOVE(M_NT,,,M_POSZ,MS_ST)
ENDIF

;***** mis secondo punto *****
MS_MOVE(M_NT,PUNX[1],PUNY[1],,MS_RAPID)
IF M_TC<>2
MS_MOVE(M_NT,,,M_Z-MS_D,MS_RAPID)
ENDIF
G1 G90 G60 MEAS=MS_INPUTS F=MS_ST AX[MS_X]=(PUDX[1]-MS_X_SHIFT) AX[MS_Y]=(PUDY[1]-MS_Y_SHIFT)
MEX[1]=$AA_MW[MS_X]+MS_X_SHIFT
MEY[1]=$AA_MW[MS_Y]+MS_Y_SHIFT
IF $AC_MEA[MS_ABS_INPUT]==0
 MS_ALM(201)
ENDIF
G1 G90 G60 F=MS_RAPID AX[MS_X]=(PUNX[1]-MS_X_SHIFT) AX[MS_Y]=(PUNY[1]-MS_Y_SHIFT)

MS_MOVE(M_NT,PUNX[1],PUNY[1],,MS_RAPID)
IF M_TC<>2
MS_MOVE(M_NT,,,M_POSZ,MS_ST)
ENDIF

;***** mis terzo punto *****

MS_MOVE(M_NT,PUNX[2],PUNY[2],,MS_RAPID)
IF M_TC<>2
MS_MOVE(M_NT,,,M_Z-MS_D,MS_RAPID)
ENDIF
G1 G90 G60 MEAS=MS_INPUTS F=MS_ST AX[MS_X]=(PUDX[2]-MS_X_SHIFT) AX[MS_Y]=(PUDY[2]-MS_Y_SHIFT)
MEX[2]=$AA_MW[MS_X]+MS_X_SHIFT
MEY[2]=$AA_MW[MS_Y]+MS_Y_SHIFT
IF $AC_MEA[MS_ABS_INPUT]==0
 MS_ALM(201)
ENDIF
G1 G90 G60 F=MS_RAPID AX[MS_X]=(PUNX[2]-MS_X_SHIFT) AX[MS_Y]=(PUNY[2]-MS_Y_SHIFT)

MS_MOVE(M_NT,PUNX[2],PUNY[2],,MS_RAPID)
MS_MOVE(M_NT,,,M_POSZ,MS_RAPID)
MS_MOVE(M_NT,,,M_POSZ,MS_ST)
MS_MOVE(M_NT,0,0,,MS_RAPID)
MS_MOVE(M_NT,0,0,,MS_ST)

;*****memorizzazione dati tastatore****

IF M_TC==1 ;sto usando un perno
RAGGIO[0]=(SQRT(POT(MEX[0])+POT(MEY[0])))-MS_ALFA[M_NT]
RAGGIO[1]=(SQRT(POT(MEX[1])+POT(MEY[1])))-MS_BETA[M_NT]
RAGGIO[2]=(SQRT(POT(MEX[2])+POT(MEY[2])))-MS_GAMMA[M_NT]
ENDIF

IF (M_TC==2) OR (M_TC==3) ;sto usando un foro
RAGGIO[0]=(SQRT(POT(MEX[0])+POT(MEY[0])))+MS_ALFA[M_NT]
RAGGIO[1]=(SQRT(POT(MEX[1])+POT(MEY[1])))+MS_BETA[M_NT]
RAGGIO[2]=(SQRT(POT(MEX[2])+POT(MEY[2])))+MS_GAMMA[M_NT]
ENDIF

STOPRE
SAB[0,0]=COS(M_ALFA)*RAGGIO[0]
SAB[0,1]=SIN(M_ALFA)*RAGGIO[0]
SAB[1,0]=COS(M_BETA)*RAGGIO[1]
SAB[1,1]=SIN(M_BETA)*RAGGIO[1]
SAB[2,0]=COS(M_GAMMA)*RAGGIO[2]
SAB[2,1]=SIN(M_GAMMA)*RAGGIO[2]
STOPRE
STATUS=CALCDAT(SAB,3,ERG)
MS_ERR_X=ERG[0]
MS_ERR_Y=ERG[1]
MS_DIAM_REAL=(ERG[2]*2)
MS_DIAM_ERR=MS_DIAM_REAL-M_DIA
;**************************************

;********controllo tolleranza**********
IF M_TOLL<>0
 IF ABS(MS_DIAM_ERR)>=M_TOLL GOTOF ALLARME2
ENDIF
;**************************************
;******** Correzione Utensile

IF M_CHECK<=1 GOTOF LBL10
IF M_DUPLO==0
M_DUPLO=1
ENDIF

IF MS_TOOLM==1
 T_INT=GETT(M_TOOLN,M_DUPLO)
 IF T_INT==-1 GOTOF ALARM5
ELSE
 IF NOT (ISNUMBER(M_TOOLN)) GOTOF ALARM5
 T_INT=TRUNC(NUMBER(M_TOOLN))
ENDIF

IF (M_TC==1) ;perno
IF M_CHECK==2  ;cor. raggio su geometria 
 $TC_DP6[T_INT,M_TOOLD]=$TC_DP6[T_INT,M_TOOLD]-(MS_DIAM_ERR/2)
 $TC_DP15[T_INT,M_TOOLD]=0
ELSE          ;cor. raggio su usura
 $TC_DP15[T_INT,M_TOOLD]=$TC_DP15[T_INT,M_TOOLD]-(MS_DIAM_ERR/2)
ENDIF
ENDIF

IF (M_TC<>1) ;foro
IF M_CHECK==2  ;cor. raggio su geometria 
 $TC_DP6[T_INT,M_TOOLD]=$TC_DP6[T_INT,M_TOOLD]+ (MS_DIAM_ERR/2)
 $TC_DP15[T_INT,M_TOOLD]=0
ELSE          ;cor. raggio su usura
 $TC_DP15[T_INT,M_TOOLD]=$TC_DP15[T_INT,M_TOOLD]+ (MS_DIAM_ERR/2)
ENDIF
ENDIF

LBL10:
;********archiviazione dati************
IF ISNUMBER(M_TITO)<>32
 MS_DIAM_REAL=(TRUNC(MS_DIAM_REAL*1000))/1000
 MS_DIAM_ERR=(TRUNC(MS_DIAM_ERR*1000))/1000
 MS_ERR_X=(TRUNC(MS_ERR_X*1000))/1000
 MS_ERR_Y=(TRUNC(MS_ERR_Y*1000))/1000
 STOPRE
 SCRIVI="(MS_3HP)      "<<$A_DAY<<"-"<<$A_MONTH<<"-"<<$A_YEAR<<"  "<<$A_HOUR<<":"<<$A_MINUTE<<":"<<$A_SECOND<<""
 MS_SAVE(M_TITO,SCRIVI)
 SCRIVI="D=  "<<MS_DIAM_REAL<<" E= "<<MS_DIAM_ERR<<""
 MS_SAVE(M_TITO,SCRIVI)
 SCRIVI="X=  "<<(MS_ERR_X+M_X)<<" Y= "<<(MS_ERR_Y+M_Y)<<""
 MS_SAVE(M_TITO,SCRIVI)
 SCRIVI="______________________END______________________"
 MS_SAVE(M_TITO,SCRIVI)
ENDIF
;**************************************

;*******aggiornamento origine**********
IF M_ORIG<>0
 IF M_ORIG>0  ; modifica campo GROSSOLANO e resetta gli altri
   IF M_ORIG==$P_UIFRNUM ;origine da modificare uguale a origine attiva
    $P_UIFR[M_ORIG,MS_X,TR]=$P_UIFR[$P_UIFRNUM,MS_X,TR]+MS_ERR_X
    $P_UIFR[M_ORIG,MS_Y,TR]=$P_UIFR[$P_UIFRNUM,MS_Y,TR]+MS_ERR_Y
    $P_UIFR[M_ORIG,MS_X,FI]=0
    $P_UIFR[M_ORIG,MS_Y,FI]=0
    $P_UIFR[M_ORIG,MS_X,RT]=0
    $P_UIFR[M_ORIG,MS_Y,RT]=0
    $P_UIFR[M_ORIG,MS_X,SC]=1
    $P_UIFR[M_ORIG,MS_Y,SC]=1
    $P_UIFR[M_ORIG,MS_X,MI]=0
    $P_UIFR[M_ORIG,MS_Y,MI]=0
   ELSE ;M_ORIG<>$P_UIFRNUM origine da modificare diversa da origine attiva
    $P_UIFR[M_ORIG,MS_X,TR]=$P_UIFR[$P_UIFRNUM,MS_X,TR]+MS_ERR_X+M_X
    $P_UIFR[M_ORIG,MS_Y,TR]=$P_UIFR[$P_UIFRNUM,MS_Y,TR]+MS_ERR_Y+M_Y
    $P_UIFR[M_ORIG,MS_X,FI]=0
    $P_UIFR[M_ORIG,MS_Y,FI]=0
    $P_UIFR[M_ORIG,MS_X,RT]=0
    $P_UIFR[M_ORIG,MS_Y,RT]=0
    $P_UIFR[M_ORIG,MS_X,SC]=1
    $P_UIFR[M_ORIG,MS_Y,SC]=1
    $P_UIFR[M_ORIG,MS_X,MI]=0
    $P_UIFR[M_ORIG,MS_Y,MI]=0
   ENDIF
 ELSE ;M_ORIG<0   modifica campo FINE e non tocca gli altri
    M_ORIG=ABS(M_ORIG)
    $P_UIFR[M_ORIG,MS_X,FI]=MS_ERR_X
    $P_UIFR[M_ORIG,MS_Y,FI]=MS_ERR_Y
 ENDIF
ENDIF
;**************************************
;**************************************
TRANS
CALL AUXOUT ;richiamo ausiliare uscita
IF ((CODICE==0) AND (MS_ACT==1))
 M=(MS_SOFF)
ENDIF 
D=MS_DA
M17

ALLARME1:;tocco anticipato
MS_ALM(202)
ALLARME2:;fuori tolleranza
MS_ALM(203)
M17
